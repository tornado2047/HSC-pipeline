
rt=read.table("Young.txt",sep="\t",header=T,check.names=F)
rt <- rt[,-2]
dim(rt)
rt=as.matrix(rt)
rownames(rt)=rt[,1]
exp=rt[,2:ncol(rt)]
dimnames=list(rownames(exp),colnames(exp))
data_young=matrix(as.numeric(as.matrix(exp)),nrow=nrow(exp),dimnames=dimnames)
data_young=avereps(data_young)
dim(data_young)


qt=read.table("Old.txt",sep="\t",header=T,check.names=F)
qt <- qt[,-2]
dim(qt)
qt=as.matrix(qt)
rownames(qt)=qt[,1]
exp1=qt[,2:ncol(qt)]
dimnames=list(rownames(exp1),colnames(exp1))
data_old=matrix(as.numeric(as.matrix(exp1)),nrow=nrow(exp1),dimnames=dimnames)
data_old=avereps(data_old)
dim(data_old)

Y <- CreateSeuratObject(counts = data_young , project = "Young")
O <- CreateSeuratObject(counts = data_old, project = "Old")
hsc <- merge(Y, y = O, add.cell.ids = c("Young", "Old"), project = "hsc")


#将矩阵转换为Seurat对象，并对数据进行过滤;数据集中测到的少于200个基因的细胞（min.features = 200）和少于3个细胞覆盖的基因（min.cells = 3）被过滤掉
annotations <- read.csv("annotation.csv")

# 创建一个匹配细胞名的索引
match_index <- match(annotations$Cell.id, colnames(hsc))

# 确保有匹配的细胞名
if (!any(is.na(match_index))) {
  # 将Group和Mtio.dist信息添加到Seurat对象中
  hsc$Group <- annotations$Group[match_index]
  hsc$Mito.dist <- annotations$Mtio.dist[match_index]
} else {
  cat("无法找到匹配的细胞名。请确保annotations数据框中的细胞名与Seurat对象的细胞名匹配。\n")
}

hsc$Group
hsc$Mito.dist
hsc$orig.ident
head(colnames(hsc))
table(hsc$orig.ident)

###### 质控的参数主要有两个： 
#### 1.每个细胞测到的unique feature数目（unique feature代表一个细胞检测到的基因的数目，可以根据数据的质量进行调整） 
#### 2.每个细胞检测到的线粒体基因的比例，理论上线粒体基因组与核基因组相比，只占很小一部分。所以线粒体基因表达比例过高的细胞会被过滤。

#使用Percentage FeatureSet函数计算线粒体基因的百分比

hsc[["percent.mt"]] <- PercentageFeatureSet(object = hsc, pattern = "^mt-")

pdf(file="featureViolin.pdf",width=10,height=6)           
VlnPlot(object = hsc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
dev.off()

#去除线粒体基因表达比例过高的细胞，和一些极值细胞
hsc <- subset(hsc, subset = nFeature_RNA > 200 & percent.mt < 5)
###### 标准化
#对数据进行标准化
hsc <- NormalizeData(object = hsc, normalization.method = "LogNormalize", scale.factor = 10000)
#提取那些在细胞间变异系数较大的基因

hsc <- FindVariableFeatures(object = hsc, selection.method = "vst", nfeatures = 2000)
#输出特征方差图
top20 <- head(x = VariableFeatures(object = hsc), 20)
pdf(file="featureVar.pdf",width=10,height=6)              
#保存基因特征方差图
plot1 <- VariableFeaturePlot(object = hsc)
plot2 <- LabelPoints(plot = plot1, points = top20, repel = TRUE)
CombinePlots(plots = list(plot1, plot2))
dev.off()


#####  细胞分类  ##PCA分析
all.genes <- rownames(hsc)
hsc <- ScaleData(hsc, features = all.genes)

#PCA降维之前的标准预处理步骤
hsc <- RunPCA(hsc, features = VariableFeatures(object = hsc))

#绘制每个PCA成分的相关基因
pdf(file="pcaGene.pdf",width=10,height=8)
VizDimLoadings(object = hsc, dims = 1:4, reduction = "pca",nfeatures = 20)
dev.off()

#主成分分析图形
pdf(file="PCA.pdf",width=6.5,height=6)
DimPlot(object = hsc, reduction = "pca")
dev.off()

#主成分分析热图
pdf(file="pcaHeatmap.pdf",width=10,height=8)
DimHeatmap(object = hsc, dims = 1:4, cells = 217, balanced = TRUE)
#1：4是热图分成几个，ncol是分为几列。
dev.off()

ElbowPlot(object = hsc)

#每个PC的p值分布和均匀分布
hsc <- JackStraw(object = hsc, num.replicate = 100)
hsc <- ScoreJackStraw(object = hsc, dims = 1:10)
pdf(file="pcaJackStraw.pdf",width=8,height=6)
JackStrawPlot(object = hsc, dims = 1:10)
dev.off()

###############################################################################################

### *****细胞聚类********
hsc <- FindNeighbors(hsc, dims = 1:10)

hsc <- FindClusters(hsc, resolution = 0.8)

# 运行Louvain算法，并尝试不同的分辨率值
resolution_values <- c(0.2, 0.4, 0.6, 0.8, 1.0)  # 可以根据需要调整这些值

for (resolution in resolution_values) {
  seurat_object <- FindClusters(hsc, resolution = resolution)
  modularity <- hsc@assays$integrated_modularity_score
  
  cat("Resolution:", resolution, "\tMaximum Modularity:", max(modularity), "\n")
}

#这里我们设置了dims = 1:10 即选取前10个主成分来分类细胞。
clusterN <- FindClusters(hsc, resolution = seq(0.2,1.6,by=0.2))
clustree(clusterN)

pdf(file="clustree.pdf",width=6.5,height=6)
clustree(clusterN)
dev.off()


#Look at cluster IDs of the first 5 cells
head(Idents(hsc), 10)
write.table(Idents(hsc),file="Cluster.txt",quote=F,sep="\t",col.names=F)

#UMAP
hsc <- RunUMAP(hsc,dims = 1:10, label = T)
head(hsc@reductions$umap@cell.embeddings) 

# 提取UMAP坐标值。
write.table(hsc@reductions$umap@cell.embeddings,file="umap.txt",quote=F,sep="\t",col.names=F)

#note that you can set `label = TRUE` or use the Label Clusters function to help label individual clusters
h <- DimPlot(hsc, pt.size =2,label.size =6,reduction = "umap",label = T)


####   pdf(file="07.umap.pdf",width=8,height=6)
####   dev.off()

#T-SNE
hsc <- RunTSNE(hsc,dims = 1:10, label = T)
head(hsc@reductions$tsne@cell.embeddings)
write.table(hsc@reductions$tsne@cell.embeddings,file="tsne.txt",quote=F,sep="\t",col.names=F)
dev.new()
pdf(file="graph.pdf",width=8,height=6)
p2 <- DimPlot(hsc, reduction = "tsne")
p2
p1 + p2
dev.off()


dev.new()
pdf(file="ident-graph.pdf",width=8,height=6)

h1 <- DimPlot(hsc, group.by = "orig.ident",pt.size =2,label.size =60,reduction = "umap")
h1

h2 <- DimPlot(hsc, group.by = "Group",pt.size =2,label.size =60,reduction = "umap")
h2

h3 <- DimPlot(hsc, group.by = "Mito.dist",pt.size =2,label.size =60,reduction = "umap")
h3


h|h2



# 提取UMAP坐标和Mito.dist信息
umap_coords <- as.data.frame(hsc@reductions$umap@cell.embeddings)
mito_dist <- hsc$Mito.dist

# 创建一个包含UMAP坐标和Mito.dist的数据框
trend.data <- cbind(umap_coords, Mito.dist = mito_dist)
head(trend.data)

# 将Mito.dist列中的字符映射到数值
trend.data$Mito.dist[trend.data$Mito.dist == "SD"] <- 1
trend.data$Mito.dist[trend.data$Mito.dist == "LD"] <- 0.8
trend.data$Mito.dist[trend.data$Mito.dist == "LP"] <- 0

# 定义一个函数来计算fixed.value
calculate_fixed_value <- function(data, k) {
  fixed_values <- numeric(length(data$UMAP_1))
  for (i in 1:length(data$UMAP_1)) {
    point <- c(data$UMAP_1[i], data$UMAP_2[i])
    distances <- sqrt((data$UMAP_1 - point[1])^2 + (data$UMAP_2 - point[2])^2)
    sorted_distances <- sort(distances)
    closest_points <- data$Mito.dist[distances %in% sorted_distances[1:k]]
    fixed_values[i] <- mean(as.numeric(closest_points))
  }
  return(fixed_values)
}

# 设置k值
k <- 5

# 计算fixed.value
trend.data$fixed.value <- calculate_fixed_value(trend.data, k)


# 创建ggplot图表，去掉背景网格线，显示坐标轴
h4 <- ggplot(trend.data, aes(x = UMAP_1, y = UMAP_2, color = fixed.value)) +
  geom_point(size = 2) +
  scale_color_gradient(low = "palegreen", high = "deeppink",limits = c(0, 1)) +
  labs(color = "trendency of dist.") +
  theme_minimal() +  # 使用theme_minimal()来设置最小主题
  theme(
    panel.grid = element_blank(),  # 去掉网格线
    axis.line = element_line(size = 0.5, color = "black"),  # 显示坐标轴线
    axis.text = element_text(size = 12),  # 调整坐标轴文本大小
    axis.title = element_text(size = 14),  # 调整坐标轴标题大小
    axis.ticks = element_line(size = 0.5),
    legend.position = "right",  # 图例放置在右侧
    legend.title = element_text(size = 12),  # 调整图例标题大小
    legend.text = element_text(size = 10)  # 调整图例文本大小
  )
h4



h1|h4


# g2 <- DimPlot(data.combined, split.by = "orig.ident",pt.size =2,label.size =60,reduction = "umap")
g3 <- DimPlot(hsc, pt.size =2,label.size =60,reduction = "umap")
# DimPlot(data.combined, pt.size =2,label.size =60,split.by = "orig.ident",reduction = "tsne")

g3|h3
dev.off()


head(hsc$Mito.dist,20)

# find markers for every cluster compared to all remaining cells, report only the positive ones
## pbmc.markers <- FindAllMarkers(pbmc, min.pct = 0.25, logfc.threshold = 0.25)  ###only.pos = TRUE
# write.table(pbmc.markers,file="five_cluster_marker.xls",quote=F,sep="\t",col.names=F)

hsc.markers <- FindAllMarkers(hsc, only.pos = TRUE, min.pct = 0.25)
## ?FindMarkers 
write.table(hsc.markers,file="marker.xls",quote=F,sep="\t",col.names=F)
head(hsc.markers)


gene_set <- unique(hsc.markers$gene)
length(gene_set)

# 山脊图
r1 <- RidgePlot(hsc, features = "Gdf15", fill.by = 'feature')
r1


hsc.allmarkers <- FindAllMarkers(hsc,min.pct = 0.25)
## ?FindMarkers

write.table(hsc.allmarkers,file="allmarker.xls",quote=F,sep="\t",col.names=F)
head(hsc.markers)

stat_marker <- subset(hsc.allmarkers, p_val_adj<0.05&abs(avg_log2FC)>0.2)  

head(stat_marker)
write.table(stat_marker,file="stat_marker.xls",quote=F,sep="\t",col.names=F)

head(hsc.markers) 

top_20 <- hsc.markers %>% group_by(cluster) %>% top_n(n = 20, wt = avg_log2FC)

top_50 <- hsc.markers %>% group_by(cluster) %>% top_n(n = 50, wt = avg_log2FC)

dev.new()
DoHeatmap(hsc, features = top_50$gene) + NoLegend()
write.table(top_50 ,file="top_50.xls",quote=F,sep="\t",col.names=F)

top_200 <- hsc.markers %>% group_by(cluster) %>% top_n(n =200, wt = avg_log2FC)
dev.new()
pdf(file="marker_heatmap.pdf",width=124,height=124)
DoHeatmap(hsc, features = top_200$gene) + NoLegend()
dev.off()
write.table(top_200 ,file="top_200.xls",quote=F,sep="\t",col.names=F)


hsc$seurat_clusters <- factor(x = hsc$seurat_clusters, levels = c("3","1","4","2","0"))  

DoHeatmap(hsc, features = as.character(unique(top_20$gene)), group.by = "seurat_clusters", assay = "RNA", 
          group.colors =c("seagreen3","goldenrod1", "orchid3","darkorange1","dodgerblue")) +
          scale_fill_gradientn(colors =c("#3580BB","#16171A","#F2D238"))
          # +theme(
          # axis.text.y = element_text(size = 5,family = "Arial", face = "bold") # 替换 YOUR_Y_FONT_SIZE 为y轴字体大小
          # )





c("#D16BA5","#86A8E7","#5FFBF1")
c("navy","ivory2","firebrick3")
c("#3580BB","#16171A","#F2D238")


saveRDS(hsc, file = "hsc.rds")



# 假设hsc是您的Seurat对象
hsc$seurat_clusters
# 查看原始的水平
levels(hsc$seurat_clusters)

# 将聚类编号转换为数值
hsc$seurat_clusters <- as.numeric(as.character(hsc$seurat_clusters))

# 重新编号为从1开始的顺序
hsc$seurat_clusters <- seq_along(unique(hsc$seurat_clusters))[match(hsc$seurat_clusters, unique(hsc$seurat_clusters))]

unique(hsc$seurat_clusters)



pdf(file="Gdf15.pdf",width=12,height=8)
m1 <- VlnPlot(hsc, features = c("Gdf15"))
m2 <- VlnPlot(hsc, features =c("Gdf15"), slot = "counts", log = TRUE)
m1 + m2
dev.off()

FeaturePlot(hsc, features = "Dcxr")

#  pdf(file = "Gdf15-feature-plot.pdf")
m4 <- FeaturePlot(hsc, features = c("Mlf1"))
m4|g3
m2 <- FeaturePlot(hsc, features = c("Dcxr"))
m2|g3
m3 <- FeaturePlot(hsc, features = c("Ung"))
m3|g3
m1 <- FeaturePlot(hsc, features = c("Espl1"))
m1|g3

m0 <- FeaturePlot(hsc, features = c("Retnlg"))
m0|g3

m5 <- FeaturePlot(hsc, features = c("Gdf15"))
m5|g3

dev.off()





m1_Fis1 <- VlnPlot(hsc, features = c("Fis1"))
m3_Fis1 <- FeaturePlot(hsc, features = c("Gdf15"))

m1+m1_Fis1
m3+m3_Fis1

m1_Dnm1l <- VlnPlot(hsc, features = c("Dnm1l"))
m3_Dnm1l <- FeaturePlot(hsc, features = c("Dnm1l"))

m1+m1_Dnm1l
m3+m3_Dnm1l

q1 <- FeaturePlot(hsc, features = c("Dnm1l","Gdf15"),pt.size = 3, keep.scale = "all")
q1



m1_Mff <- VlnPlot(hsc, features = c("Mff"))
m3_Mff <- FeaturePlot(hsc, features = c("Mff"))

m1+m1_Mff
m3+m3_Mff

m1_Ret <- VlnPlot(hsc, features = c("Ret"))
m3_Ret <- FeaturePlot(hsc, features = c("Ret"))

m1+m1_Ret
m3+m3_Ret

m1_Dnm2 <- VlnPlot(hsc, features = c("Dnm2"))
m3_Dnm2 <- FeaturePlot(hsc, features = c("Dnm2"))
m3_Dnm2

q2 <- FeaturePlot(hsc, features = c("Dnm2","Gdf15"),pt.size = 3, keep.scale = "all")
q2

q3 <- FeaturePlot(hsc, features = c("Drp1","Gdf15"),pt.size = 3, keep.scale = "all")
q3

q4 <- FeaturePlot(hsc, features = c("Gdf15","Mief2","Tgfbr2","Dnm2","Dnm1",
                                    "Dnm1l","Mff","Mfn1","Mfn2"),pt.size = 3, keep.scale = "all")
q4




genes <- c("S100a8","Hmgb2","Hmox1","Ung","Ccnb1")
DotPlot(hsc, features = genes, group.by ="seurat_clusters", dot.scale = 8)
FeaturePlot(hsc, features =genes ,pt.size = 3, keep.scale = "all")



genes_new <- c("Clu","Ier3","Ubc","Bmp4","Gdf15")
DotPlot(hsc, features = genes_new, group.by ="seurat_clusters", dot.scale = 8)
FeaturePlot(hsc, features =genes_new ,pt.size = 2, keep.scale = "all")


DotPlot(hsc, features = c("Dnm2","PINK1","Mfn2","Fis1","Mff","Opa1"), group.by ="seurat_clusters", dot.scale = 8)










output_df<- read.csv("ER_factor.csv")

# install.packages("ggalluvial")
library(ggalluvial)

#########  挑选出ER-factor 进行再聚类

ER_factors <- output_df[!duplicated(output_df$ER_factor) | duplicated(output_df$ER_factor, fromLast = TRUE), ]
ER_factors <- ER_factors[,1]


hsc_obj <- RunPCA(hsc, features = ER_factors)
VizDimLoadings(hsc_obj, dims = 1:2, reduction = "pca")
DimHeatmap(hsc_obj, dims = 1, balanced = TRUE)

t_np <- DimPlot(hsc_obj, reduction = "pca",pt.size = 2)
t_np



### allmarker venn 
install.packages("VennDiagram")
install.packages("futile.logger")
library(grid)
library(VennDiagram)

hsc.allmarkers





cluster0.markers <- FindMarkers(hsc, ident.1 = 0, min.pct = 0.25)
head(cluster0.markers)
# rownames(cluster0.markers)
cluster1.markers <- FindMarkers(hsc, ident.1 = 1, min.pct = 0.25)
cluster2.markers <- FindMarkers(hsc, ident.1 = 2, min.pct = 0.25)
cluster3.markers <- FindMarkers(hsc, ident.1 = 3, min.pct = 0.25)
cluster4.markers <- FindMarkers(hsc, ident.1 = 4, min.pct = 0.25)
write.table(cluster0.markers,file="cluster0.markers.xls",quote=F,sep="\t",col.names=F)
write.table(cluster1.markers,file="cluster1.markers.xls",quote=F,sep="\t",col.names=F)
write.table(cluster2.markers,file="cluster2.markers.xls",quote=F,sep="\t",col.names=F)
write.table(cluster3.markers,file="cluster3.markers.xls",quote=F,sep="\t",col.names=F)
write.table(cluster4.markers,file="cluster4.markers.xls",quote=F,sep="\t",col.names=F)
cluster3.markers
A <- rownames(cluster0.markers)
B <- rownames(cluster1.markers)
C <- rownames(cluster2.markers)
D <- rownames(cluster3.markers)
E <- rownames(cluster4.markers)

venn_list <- list(Cluster_0 = A,Cluster_1  = B,Cluster_2 = C,Cluster_3 = D,Cluster_4 = E)

venn.plot <- venn.diagram( 
  venn_list,
  filename = "Venn_5set.png", 
  col = "black", 
  fill = c("dodgerblue", "goldenrod1", "darkorange1", "seagreen3", "orchid3"), 
  alpha = 0.50, 
  cat.col = c("darkblue", "darkgreen", "orange", "grey50","purple"), 
  cat.cex = 0.75, 
  cat.fontface = "bold", 
  margin = 0.05);


inter <- get.venn.partitions(venn_list)
for (i in 1:nrow(inter)) inter[i,'values'] <- paste(inter[[i,'..values..']], collapse = ', ')
head(inter)
inter <- as.data.frame(inter)
inter$..values..$`1`
write.csv(inter$..values..$`1`, "130.csv", row.names = F)

rownames(kg)

# marker gene analysis
pdf(file="latentmarker_vinplot.pdf",width=16,height=36)
VlnPlot(hsc, features = rownames(kg))
dev.off()

pdf(file="33marker_vinplot.pdf",width=16,height=36)
VlnPlot(hsc, features = rownames(fg))
dev.off()

# visualizes gene expression on a tSNE or PCA plot

pdf(file="33marker_featureplot.pdf",width=20,height=36)
FeaturePlot(hsc, features = rownames(fg))
dev.off()

# Plk2 Gdf15 Asf1b

pdf(file="3genes_VlnPlot.pdf",width=9,height=3)
VlnPlot(hsc, features = c("Gdf15","Asf1b","Plk2"))
dev.off()

pdf(file="3genes_FeaturePlot.pdf")
FeaturePlot(hsc, features = c("Gdf15","Asf1b","Plk2"))
dev.off()

#########################################################################################################
# Seurat可视化SCENIC结果
# setwd("E:/zxf/workspace/SCENIC_HSC")

##导入原始regulonAUC矩阵
AUCmatrix <- readRDS("int/3.4_regulonAUC.Rds")
AUCmatrix <- AUCmatrix@assays@data@listData$AUC
AUCmatrix <- data.frame(t(AUCmatrix), check.names=F)
RegulonName_AUC <- colnames(AUCmatrix)
RegulonName_AUC <- gsub(' \\(','_',RegulonName_AUC)
RegulonName_AUC <- gsub('\\)','',RegulonName_AUC)
colnames(AUCmatrix) <- RegulonName_AUC
scRNAauc <- AddMetaData(hsc, AUCmatrix)
scRNAauc@assays$integrated <- NULL
saveRDS(scRNAauc,'scRNAauc.rds')

##导入二进制regulonAUC矩阵
BINmatrix <- readRDS("int/4.1_binaryRegulonActivity.Rds")
BINmatrix <- data.frame(t(BINmatrix), check.names=F)
RegulonName_BIN <- colnames(BINmatrix)
RegulonName_BIN <- gsub(' \\(','_',RegulonName_BIN)
RegulonName_BIN <- gsub('\\)','',RegulonName_BIN)
colnames(BINmatrix) <- RegulonName_BIN
scRNAbin <- AddMetaData(hsc, BINmatrix)
scRNAbin@assays$integrated <- NULL
saveRDS(scRNAbin, 'scRNAbin.rds')

##利用Seurat可视化AUC
dir.create('scenic_seurat')
#FeaturePlot

head(AUCmatrix)
dev.new()
p1 = FeaturePlot(scRNAauc, features='Rel_extended_31g', label=F, reduction = 'umap')
p2 = FeaturePlot(scRNAbin, features='Rel_extended_31g', label=F, reduction = 'umap')
p3 = DimPlot(hsc, reduction = 'umap', group.by = "seurat_clusters", label=F)
plotc = p1|p2|p3
plotc
p1
p2
p3


### 提取cluster markers 的原始表达矩阵
str(hsc)
cells_select <- WhichCells(hsc,ident=0)

### 读取被选markers
class(stat_marker)
DEGs0 <- subset(stat_marker, cluster == 0)
DEGs1 <- subset(stat_marker, cluster == 1)
DEGs2 <- subset(stat_marker, cluster == 2)
DEGs3 <- subset(stat_marker, cluster == 3)
DEGs4 <- subset(stat_marker, cluster == 4)

gene_names0 <- DEGs0$gene
gene_names1 <- DEGs1$gene
gene_names2 <- DEGs2$gene
gene_names3 <- DEGs3$gene
gene_names4 <- DEGs4$gene

head(gene_names1)


# gene_names <- read.table("list.txt",sep="\t",header=T,check.names=F)
# head(gene_names)
# class(gene_names)
# gene_names <- gene_names[,1]

### cluster0中markers的counts
# markers_matrix_cluster0 <- as.matrix(GetAssayData(hsc,slot = "counts")[gene_names,cells_select])
# head(markers_matrix_cluster0)
# write.csv(markers_matrix_cluster0,file = "markers_matrix_cluster0.csv")
# 
# 
# markers_matrix_cluster1 <- as.matrix(GetAssayData(hsc,slot = "counts")[gene_names,WhichCells(hsc,ident=1)])
# head(markers_matrix_cluster1)
# write.csv(markers_matrix_cluster1,file = "markers_matrix_cluster1.csv")
# 
# markers_matrix_cluster2 <- as.matrix(GetAssayData(hsc,slot = "counts")[gene_names,WhichCells(hsc,ident=2)])
# write.csv(markers_matrix_cluster2,file = "markers_matrix_cluster2.csv")
# 
# markers_matrix_cluster3 <- as.matrix(GetAssayData(hsc,slot = "counts")[gene_names,WhichCells(hsc,ident=3)])
# write.csv(markers_matrix_cluster3,file = "markers_matrix_cluster3.csv")
# 
# markers_matrix_cluster4 <- as.matrix(GetAssayData(hsc,slot = "counts")[gene_names,WhichCells(hsc,ident=4)])
# write.csv(markers_matrix_cluster4,file = "markers_matrix_cluster4.csv")

# K <- subset(stat_marker, features = gene_names)

markers_matrix_cluster0 <- as.matrix(GetAssayData(hsc,slot = "counts")[gene_names0,cells_select])
head(markers_matrix_cluster0)
write.csv(markers_matrix_cluster0,file = "markers_matrix_cluster0.csv")


markers_matrix_cluster1 <- as.matrix(GetAssayData(hsc,slot = "counts")[gene_names1,WhichCells(hsc,ident=1)])
head(markers_matrix_cluster1)
write.csv(markers_matrix_cluster1,file = "markers_matrix_cluster1.csv")

markers_matrix_cluster2 <- as.matrix(GetAssayData(hsc,slot = "counts")[gene_names2,WhichCells(hsc,ident=2)])
write.csv(markers_matrix_cluster2,file = "markers_matrix_cluster2.csv")

markers_matrix_cluster3 <- as.matrix(GetAssayData(hsc,slot = "counts")[gene_names3,WhichCells(hsc,ident=3)])
write.csv(markers_matrix_cluster3,file = "markers_matrix_cluster3.csv")

markers_matrix_cluster4 <- as.matrix(GetAssayData(hsc,slot = "counts")[gene_names4,WhichCells(hsc,ident=4)])
write.csv(markers_matrix_cluster4,file = "markers_matrix_cluster4.csv")


K <- subset(stat_marker, gene == "Gdf15")



# 不同resolution下的分群情况
HSC <- merge(Y, y = O, add.cell.ids = c("Young", "Old"), project = "hsc")
#使用Percentage FeatureSet函数计算线粒体基因的百分比
HSC[["percent.mt"]] <- PercentageFeatureSet(object = HSC, pattern = "^mt-")
#去除线粒体基因表达比例过高的细胞，和一些极值细胞
HSC <- subset(HSC, subset = nFeature_RNA > 200 & percent.mt < 5)
###### 标准化
#对数据进行标准化
HSC <- NormalizeData(object = HSC, normalization.method = "LogNormalize", scale.factor = 10000)
#提取那些在细胞间变异系数较大的基因
HSC <- FindVariableFeatures(object = HSC, selection.method = "vst", nfeatures = 2000)
#####  细胞分类  ##PCA分析
all.genes <- rownames(HSC)
HSC <- ScaleData(HSC, features = all.genes)
#PCA降维之前的标准预处理步骤
HSC <- RunPCA(HSC, features = VariableFeatures(object = HSC))
#每个PC的p值分布和均匀分布
HSC <- JackStraw(object = HSC, num.replicate = 100)
HSC <- ScoreJackStraw(object = HSC, dims = 1:10)
### *****细胞聚类********
HSC <- FindNeighbors(HSC, dims = 1:10)




HSC_0.6 <- HSC
HSC_1 <- HSC
HSC_1.6 <- HSC


HSC_0.6 <- FindClusters(HSC_0.6, resolution = 0.6)
#UMAP
HSC_0.6 <- RunUMAP(HSC_0.6,dims = 1:10, label = T)
#note that you can set `label = TRUE` or use the Label Clusters function to help label individual clusters
h_0.6 <- DimPlot(HSC_0.6, pt.size =2,label.size =6,reduction = "umap",label = T)

h_0.6




HSC_1.6 <- FindClusters(HSC_1.6, resolution = 1.6)
#UMAP
HSC_1.6 <- RunUMAP(HSC_1.6,dims = 1:10, label = T)
#note that you can set `label = TRUE` or use the Label Clusters function to help label individual clusters
h_1.6 <- DimPlot(HSC_1.6, pt.size =2,label.size =6,reduction = "umap",label = T)

h_1.6


h_0.6|h|h_1.6|h2|h1



my_cols <- c("#845EC2", "#D65DB1", "#FF6F91", "#FF9671", "#FFC75F","#F9F871")

my_cols <- c("#845EC2", "gray", "gray", "gray", "gray","gray")

my_cols <- c("gray", "#D65DB1", "gray", "gray", "gray","gray")

my_cols <- c("gray", "gray", "#FF6F91", "gray", "gray","gray")

my_cols <- c("gray", "gray", "gray", "#FF9671", "gray","gray")

my_cols <- c("gray", "gray", "gray", "gray", "#FFC75F","gray")

my_cols <- c("gray", "gray", "gray", "gray","gray", "#F9F871")

h2 <- DimPlot(hsc, group.by = "Group",cols = my_cols,pt.size =2,label.size =60,reduction = "umap",label = F)
h2 <- h2 + theme(
  panel.grid = element_blank(),
  axis.line = element_line(size = 0.5, color = "black"), # Set the size here
  axis.text = element_text(size = 12, face = "bold"),
  axis.title = element_text(size = 14, face = "bold"),
  axis.ticks = element_line(size = 0.5),
  legend.position = "right",
  legend.title = element_text(size = 12),
  legend.text = element_text(size = 10)
)

h2


h1 <- h1 + theme(
  panel.grid = element_blank(),
  axis.line = element_line(size = 0.5, color = "black"), # Set the size here
  axis.text = element_text(size = 12, face = "bold"),
  axis.title = element_text(size = 14, face = "bold"),
  axis.ticks = element_line(size = 0.5),
  legend.position = "right",
  legend.title = element_text(size = 12),
  legend.text = element_text(size = 10)
)

h1


h_0.6 <- h_0.6 + theme(
  panel.grid = element_blank(),
  axis.line = element_line(size = 0.5, color = "black"), # Set the size here
  axis.text = element_text(size = 12, face = "bold"),
  axis.title = element_text(size = 14, face = "bold"),
  axis.ticks = element_line(size = 0.5),
  legend.position = "right",
  legend.title = element_text(size = 12),
  legend.text = element_text(size = 10)
)

h_0.6




h <- h + theme(
  panel.grid = element_blank(),
  axis.line = element_line(size = 0.5, color = "black"), # Set the size here
  axis.text = element_text(size = 12, face = "bold"),
  axis.title = element_text(size = 14, face = "bold"),
  axis.ticks = element_line(size = 0.5),
  legend.position = "right",
  legend.title = element_text(size = 12),
  legend.text = element_text(size = 10)
)

h



h_1.6 <- h_1.6 + theme(
  panel.grid = element_blank(),
  axis.line = element_line(size = 0.5, color = "black"), # Set the size here
  axis.text = element_text(size = 12, face = "bold"),
  axis.title = element_text(size = 14, face = "bold"),
  axis.ticks = element_line(size = 0.5),
  legend.position = "right",
  legend.title = element_text(size = 12),
  legend.text = element_text(size = 10)
)

h_1.6


h_0.6|h|h_1.6|h2|h1





### 整合不同分类label，比较相似性
hsc_cluster_list <- list(h2[1]$data, h_0.6[1]$data, h[1]$data, h_1.6[1]$data, h1[1]$data)

# 提取第三列
hsc_cluater <- lapply(hsc_cluster_list, function(df) {df[, 3]})

head(hsc_cluster_list)
class(hsc_cluster_list)


hsc_cluster_list[1]
class(hsc_cluater[1])

# 合并第三列
total_cluster <- do.call(cbind, hsc_cluater)
# 用第一个数据框的行名
rownames(total_cluster) <- rownames(hsc_cluster_list[[1]])

colnames(total_cluster) <- c("manaul_group", "Res_0.6", "Res_1.0","Res_1.6","age_label")


dim(total_cluster)
hsc_cluster_list


# 将每个数据框按照最后一列的值将样本分组，得到一个新 list 文件
grouped_lists <- lapply(hsc_cluster_list, function(df) {
  last_col <- names(df)[ncol(df)]  # 获取最后一列的列名
  split(df, df[, last_col])
})

length(grouped_lists)

list(grouped_lists[[1]])

library(tidyr)
library(janitor)

# image_group <- remove_empty(image_group, which = "cols")
#define Jaccard Similarity function
jaccard <- function(a, b) {
  intersection = length(intersect(a, b))
  union = length(a) + length(b) - intersection
  return (intersection/union)
}

jaccard_mutual <- function(a, b) {
  # 计算交集
  intersection = length(intersect(a, b))
  
  # 计算 a 中包含于 b 中的元素个数
  a_in_b = length(which(a %in% b))
  
  # 计算 b 中包含于 a 中的元素个数
  b_in_a = length(which(b %in% a))
  
  # 计算并集
  union = length(a) + length(b) - intersection
  
  # 计算互相包含的比例
  mutual_inclusion = (a_in_b + b_in_a) / union
  
  return (mutual_inclusion)
}

jaccard_mutual  <- function(a, b) {
  # 计算交集
  intersection = length(intersect(a, b))
  
  # 计算 a 中包含于 b 中的元素个数
  a_in_b = length(which(a %in% b))
  
  # 计算 b 的大小
  b_size = length(b)
  
  # 计算比例
  proportion = a_in_b / b_size
  
  return (proportion)
}



jaccard_mutual(L11,L21)

L11 <- rownames(grouped_lists[[1]]$OLD)
L12 <- rownames(grouped_lists[[1]]$OLP) 
L13 <- rownames(grouped_lists[[1]]$OSD)
L14 <- rownames(grouped_lists[[1]]$YLD) 
L15 <- rownames(grouped_lists[[1]]$YLP)
L16 <- rownames(grouped_lists[[1]]$YSD) 

L21 <- rownames(grouped_lists[[2]]$"0")
L22 <- rownames(grouped_lists[[2]]$"1") 
L23 <- rownames(grouped_lists[[2]]$"2")

L31 <- rownames(grouped_lists[[3]]$"0") 
L32 <- rownames(grouped_lists[[3]]$"1") 
L33 <- rownames(grouped_lists[[3]]$"2") 
L34 <- rownames(grouped_lists[[3]]$"3") 
L35 <- rownames(grouped_lists[[3]]$"4") 

L41 <- rownames(grouped_lists[[4]]$"0") 
L42 <- rownames(grouped_lists[[4]]$"1") 
L43 <- rownames(grouped_lists[[4]]$"2") 
L44 <- rownames(grouped_lists[[4]]$"3") 
L45 <- rownames(grouped_lists[[4]]$"4") 
L46 <- rownames(grouped_lists[[4]]$"5") 

L51 <- rownames(grouped_lists[[5]]$Old) 
L52 <- rownames(grouped_lists[[5]]$Young) 

#find Jaccard Similarity between the two sets 
# Define the sets L1 to L5
L1 <- list(
  L11 = rownames(grouped_lists[[1]]$OLD),
  L12 = rownames(grouped_lists[[1]]$OLP), 
  L13 = rownames(grouped_lists[[1]]$OSD),
  L14 = rownames(grouped_lists[[1]]$YLD), 
  L15 = rownames(grouped_lists[[1]]$YLP),
  L16 = rownames(grouped_lists[[1]]$YSD)
)

L2 <- list(
  L21 = rownames(grouped_lists[[2]]$"0"),
  L22 = rownames(grouped_lists[[2]]$"1"), 
  L23 = rownames(grouped_lists[[2]]$"2")
)

L3 <- list(
  L31 = rownames(grouped_lists[[3]]$"0"), 
  L32 = rownames(grouped_lists[[3]]$"1"), 
  L33 = rownames(grouped_lists[[3]]$"2"), 
  L34 = rownames(grouped_lists[[3]]$"3"), 
  L35 = rownames(grouped_lists[[3]]$"4")
)

L4 <- list(
  L41 = rownames(grouped_lists[[4]]$"0"), 
  L42 = rownames(grouped_lists[[4]]$"1"), 
  L43 = rownames(grouped_lists[[4]]$"2"), 
  L44 = rownames(grouped_lists[[4]]$"3"), 
  L45 = rownames(grouped_lists[[4]]$"4"), 
  L46 = rownames(grouped_lists[[4]]$"5")
)

L5 <- list(
  L51 = rownames(grouped_lists[[5]]$Old), 
  L52 = rownames(grouped_lists[[5]]$Young)
)

# Compute Jaccard coefficients
compute_jaccard <- function(L1, L2) {
  result <- matrix(NA, nrow = length(L1), ncol = length(L2))
  for (i in 1:length(L1)) {
    for (j in 1:length(L2)) {
      result[i, j] <- jaccard(L1[[i]], L2[[j]])
    }
  }
  colnames(result) <- names(L2)
  rownames(result) <- names(L1)
  return(result)
}

# Compute Jaccard coefficients between all pairs of L1 to L5
result_matrix <- list(
  L1_L2 = compute_jaccard(L1, L2),
  L1_L3 = compute_jaccard(L1, L3),
  L1_L4 = compute_jaccard(L1, L4),
  L1_L5 = compute_jaccard(L1, L5),
  L2_L3 = compute_jaccard(L2, L3),
  L2_L4 = compute_jaccard(L2, L4),
  L2_L5 = compute_jaccard(L2, L5),
  L3_L4 = compute_jaccard(L3, L4),
  L3_L5 = compute_jaccard(L3, L5),
  L4_L5 = compute_jaccard(L4, L5)
)


result_matrix[[1]]
result_matrix[[2]]
result_matrix[[3]]



# Write matrices to CSV files
write_matrices_to_csv <- function(matrices_list, prefix) {
  for (i in 1:length(matrices_list)) {
    filename <- paste0(prefix, "_", names(matrices_list)[i], ".csv")
    write.csv(matrices_list[[i]], file = filename)
  }
}

# Write matrices to CSV files
write_matrices_to_csv(result_matrix, "jaccard_coefficients")







compute_jaccard_mutual <- function(L1, L2) {
  result <- matrix(NA, nrow = length(L1), ncol = length(L2))
  for (i in 1:length(L1)) {
    for (j in 1:length(L2)) {
      result[i, j] <- jaccard_mutual(L1[[i]], L2[[j]])
    }
  }
  colnames(result) <- names(L2)
  rownames(result) <- names(L1)
  return(result)
}

# Compute Jaccard coefficients between all pairs of L1 to L5
mutual_matrix <- list(
  L1_L2 = compute_jaccard_mutual(L1, L2),
  L1_L3 = compute_jaccard_mutual(L1, L3),
  L1_L4 = compute_jaccard_mutual(L1, L4)

)


mutual_matrix[[1]]
mutual_matrix[[2]]
mutual_matrix[[3]]


mutual_matrix_revserse <- list(
  L2_L1 = compute_jaccard_mutual(L2, L1),
  L3_L1 = compute_jaccard_mutual(L3, L1),
  L4_L1 = compute_jaccard_mutual(L4, L1)
  
)


mutual_matrix_revserse[[1]]
mutual_matrix_revserse[[2]]
mutual_matrix_revserse[[3]]








colSums(mutual_matrix[[1]])


write_matrices_to_csv(mutual_matrix, "Proportion")
write_matrices_to_csv(mutual_matrix, "union_Proportion")
write_matrices_to_csv(mutual_matrix_revserse, "reverse-Proportion")





# Install and load required packages
# install.packages("networkD3")
library(networkD3)

# 读取连线文件和节点文件



MisLinks = read.delim("sankey/L1-L2-link.csv",sep = ",")
MisNodes = read.delim("sankey/L1-L2-node.csv",sep = ",")

MisLinks = read.delim("sankey/L1-L3-link.csv",sep = ",")
MisNodes = read.delim("sankey/L1-L3-node.csv",sep = ",")

MisLinks = read.delim("sankey/L1-L4-link.csv",sep = ",")
MisNodes = read.delim("sankey/L1-L4-node.csv",sep = ",")



MisLinks = read.delim("sankey/L5-L2-link.csv",sep = ",")
MisNodes = read.delim("sankey/L5-L2-node.csv",sep = ",")

MisLinks = read.delim("sankey/L5-L3-link.csv",sep = ",")
MisNodes = read.delim("sankey/L5-L3-node.csv",sep = ",")

MisLinks = read.delim("sankey/L5-L4-link.csv",sep = ",")
MisNodes = read.delim("sankey/L5-L4-node.csv",sep = ",")


# 处理数据
# 因为networkD3需要的连线数据，是节点文件里的名称的索引。所以，需要做一个名称到索引的转化
Node2index = list()
Node2index[MisNodes$name] = 0:length(MisNodes$name)
MisLinks = MisLinks %>%
  mutate(source2 = unlist(Node2index[source])) %>%
  mutate(target2 = unlist(Node2index[target]))

# # 定义颜色
# color2project = paste(c(unique(MisNodes$group_color),unique(MisLinks$group_color2)),collapse = '","')
# my_color <- paste0('d3.scaleOrdinal().domain(["',color2project,'"]).range(["',color2project,'"])')

# 绘图
sankeyNetwork(Links = MisLinks, 
              Nodes = MisNodes,
              Source = "source2", 
              Target = "target2",
              Value ="value",
              NodeID = "name",
              # NodeGroup = "group_color", 
              # LinkGroup  = "group_color2", 
              # colourScale = JS(my_color),
              fontSize = 12)



# age——seurat——manual 多层桑基图

## 第一层数据
layer12 <- read.delim("sankey/L5-L2-link.csv",sep = ",")
## 第二层数据
layer23 <- read.delim("sankey/L2-L1-link.csv",sep = ",")


## 第一层数据
layer12 <- read.delim("sankey/L5-L3-link.csv",sep = ",")
## 第二层数据
layer23 <- read.delim("sankey/L3-L1-link.csv",sep = ",")


## 第一层数据
layer12 <- read.delim("sankey/L5-L4-link.csv",sep = ",")
## 第二层数据
layer23 <- read.delim("sankey/L4-L1-link.csv",sep = ",")


## 合并三层数据
pdata <- rbind(layer12,layer23)

# 创建节点名称数据框
nodes <- data.frame(name = c(as.character(pdata$source), 
                             as.character(pdata$target)) %>% unique())
# 把source、target转换为数字
pdata$IDsource = match(pdata$source, nodes$name)-1
pdata$IDtarget = match(pdata$target, nodes$name)-1
head(pdata)

sankeyNetwork(Links = pdata, # 输入数据1
              Nodes = nodes, # 输入数据2
              Source = "IDsource", # 来源变量
              Target = "IDtarget", # 接受变量
              Value = "value", # 关系权重
              NodeID = "name", #节点名称
              LinkGroup = 'source', # 颜色分组
              sinksRight = FALSE, # 设置最后一层标签位置在左/右
              nodeWidth = 5, #节点格子宽度
              fontSize = 15, #文本标签字体的大小
              nodePadding = 4) #节点格子间空隙宽度







